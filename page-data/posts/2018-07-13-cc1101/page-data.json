{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/posts/2018-07-13-cc1101","webpackCompilationHash":"c8ed51f8e74f03200d92","result":{"data":{"site":{"siteMetadata":{"title":"Excursion in Distraction","author":"@dsvensson"}},"markdownRemark":{"html":"<p>A couple of months ago I moved to a house, and the need to <em>monitor-all-the-things</em> guided me towards the affordable IKEA Sparsnäs energy display. Sparsnäs is composed up of two parts, one being the transmitter that is attached to your electricity meter, and the other; the display that stores usage, and presents a variety of graphs. The downside is that there is no way of getting the data out of the display so you have to accept how it’s presented, and that it may get lost, or build something on your own. Thankfully the protocol has been thoroughly reverse engineered and <a href=\"https://github.com/kodarn/Sparsnas\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">documented</a> in a very elaborate manner. From a birds eye perspective it works by tracking how many LED blinks (per <em>n</em> kW) that have occurred, and periodically transmits that count over radio, which the display then receives and presents.</p>\n<p>In a previous experiment I learned the basics of decoding radio signals using <a href=\"https://www.rtl-sdr.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RTL-SDR</a> and <a href=\"https://github.com/atlas0fd00m/rfcat\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">RfCat</a> which made it easy to follow along with the techniques described in the very detailed reverse engineering document. I did, however, not want to tie up any of those two hardware components to measure my power use as they’re general purpose tools that I might want to use for other experiments in the future. Coincidentally, while it was still unsustainably cheap to put small orders on AliExpress I had among other electronics hoarded a $3 Texas Instruments <code class=\"language-text\">CC1101</code> radio module. After some months on the shelf this seemed like it could be its time to shine.</p>\n<p>I had no idea how to make the Ti <code class=\"language-text\">CC1101</code> work as my embedded development experience is next to none, so I started off with first getting the signal decoded using the crude but functional RTL-SDR together with the open source application <a href=\"https://github.com/strigeus/sparsnas_decoder\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">sparsnas_decoder</a>. Here I learned how to generate the key, based on the device serial number, needed to decode the packet, and was able to get my first readings. This software however does the whole radio signal processing on its own, which is something I lack the knowledge to fully grasp, and thus don’t want to maintain. I then moved on to the RfCat example script from the reverse engineering repository, equipped with the encryption key, and started changing things to see how it behaved. The <code class=\"language-text\">init</code> function configures the radio, per:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">init</span><span class=\"token punctuation\">(</span>d<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    d<span class=\"token punctuation\">.</span>setFreq<span class=\"token punctuation\">(</span><span class=\"token number\">868000000</span><span class=\"token punctuation\">)</span>            <span class=\"token comment\"># Main frequency</span>\n    d<span class=\"token punctuation\">.</span>setMdmModulation<span class=\"token punctuation\">(</span>MOD_2FSK<span class=\"token punctuation\">)</span>    <span class=\"token comment\"># Modulation type</span>\n    d<span class=\"token punctuation\">.</span>setMdmChanSpc<span class=\"token punctuation\">(</span><span class=\"token number\">40000</span><span class=\"token punctuation\">)</span>          <span class=\"token comment\"># Channel spacing</span>\n    d<span class=\"token punctuation\">.</span>setMdmDeviatn<span class=\"token punctuation\">(</span><span class=\"token number\">20000</span><span class=\"token punctuation\">)</span>          <span class=\"token comment\"># Deviation</span>\n    d<span class=\"token punctuation\">.</span>setMdmNumPreamble<span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span>         <span class=\"token comment\"># Number of preamble bits</span>\n    d<span class=\"token punctuation\">.</span>setMdmDRate<span class=\"token punctuation\">(</span><span class=\"token number\">38391</span><span class=\"token punctuation\">)</span>            <span class=\"token comment\"># Data rate</span>\n    d<span class=\"token punctuation\">.</span>setMdmSyncWord<span class=\"token punctuation\">(</span><span class=\"token number\">0xD201</span><span class=\"token punctuation\">)</span>        <span class=\"token comment\"># Sync Word</span>\n    d<span class=\"token punctuation\">.</span>setMdmSyncMode<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>             <span class=\"token comment\"># 15 of 16 bits must match</span>\n    d<span class=\"token punctuation\">.</span>makePktFLEN<span class=\"token punctuation\">(</span><span class=\"token number\">20</span><span class=\"token punctuation\">)</span>               <span class=\"token comment\"># Packet length</span>\n    d<span class=\"token punctuation\">.</span>setMaxPower<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>From there on it’s just a matter of decrypting the packets and applying the algorithm to convert pulse counts to watts.</p>\n<p>When starting a project I usually try to complicate things as much as possible to maximize learning. I could have settled with either of the two working examples I already had, but as the RfCat contains a <code class=\"language-text\">CC1111</code> chip, that initialization was probably close to what I would have to do with the <code class=\"language-text\">CC1101</code> chip to get it working. Given that assumption I surveyed GitHub for existing <code class=\"language-text\">CC1101</code> projects. There are lots of them, all the way from Python to Arduino, most of them have a constant array of register values that they apply at startup with no clear way of knowing what it does to the hardware, unless the reader is able to deduce the register values to behavior on the fly. It felt a bit dirty, especially given how readable <a href=\"http://blog.japaric.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">embedded Rust eco-system</a> looked. I saw no other way than to at least try to implement my own <code class=\"language-text\">CC1101</code> driver in Rust, preferably in a way compatible with embedded Rust should the need arise. Digging a bit more I actually found a Rust-based attempt at an embedded-compatible (<code class=\"language-text\">nostd</code>) crate, it was however only an <a href=\"https://github.com/dsvensson/cc1101/blob/51f899e25a56c3d181834286d4f7b184f43f92eb/src/lib.rs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">empty skeleton</a> with no actual communication working, but it was at least a structure to build upon which was very helpful given my Rust skill level.</p>\n<p>The <code class=\"language-text\">CC1101</code> chip is connected via something called SPI. It’s a protocol I’d heard of before, but had no idea how it actually worked. SPI is an abbreviation for Serial Peripheral Interface and <a href=\"https://en.wikipedia.org/wiki/Serial_Peripheral_Interface\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Wikipedia</a> was useful for building a mental model of what the individual pins meant and how the transmission works. As the goal would be to store the measurements in an InfluxDB I decided to connect this to the pin header of a Raspberry Pi to begin with, with the option to port this to some tiny embedded thing with wifi in the future that would forward data <em>To The Cloud!</em>. Armed with the the const arrays of <code class=\"language-text\">CC1101</code> initializers from different GitHub projects, I just threw that into the code, tweaked it a bit based on the register values mentioned in the Sparsnäs reverse engineering document and a number of brute forcing hours later I actually got my first packets! The code was a mess, it had all the flaws that I disliked about the other <code class=\"language-text\">CC1101</code>-projects but it was a starting point.</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/fb178f94d97f1eb7776946878a9d8e61/8de17/cc1101.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 650px;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGQABAAIDAAAAAAAAAAAAAAAAAAMEAQIF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAa0zWOkqDEJZMD//xAAcEAACAgIDAAAAAAAAAAAAAAABAgADEhMEETL/2gAIAQEAAQUCpyKIXYp5VK9ZrJh5GuNQnZpEroTH/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAwEBPwEf/8QAFBEBAAAAAAAAAAAAAAAAAAAAIP/aAAgBAgEBPwEf/8QAIBAAAgAFBQEAAAAAAAAAAAAAAAECESEiMRIyUWGSof/aAAgBAQAGPwJvjBdpZUth73owvSJRQ/UMyyqmf//EABwQAQEBAQACAwAAAAAAAAAAAAERADEhQVFx8f/aAAgBAQABPyHzZXgen50RAHizBi1fvIAMZTTUOC3BQ2z0mMxSvCb8JmpNXqG//9oADAMBAAIAAwAAABDrIP8A/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEREP/aAAgBAwEBPxBul3//xAAXEQEBAQEAAAAAAAAAAAAAAAABABAR/9oACAECAQE/EAS4w5//xAAgEAEAAgICAQUAAAAAAAAAAAABESEAMUFhoXGBkbHR/9oACAEBAAE/EIQaV2PdU8fOU2oBhNclkeuQcXSiMAqpKbxN1vWJQSQ2/eJ1mazw9Y5pyQQOisPJ4PxjYVujorWf/9k='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"cc1101\"\n        title=\"\"\n        src=\"/static/fb178f94d97f1eb7776946878a9d8e61/a111b/cc1101.jpg\"\n        srcset=\"/static/fb178f94d97f1eb7776946878a9d8e61/aca85/cc1101.jpg 163w,\n/static/fb178f94d97f1eb7776946878a9d8e61/0954f/cc1101.jpg 325w,\n/static/fb178f94d97f1eb7776946878a9d8e61/a111b/cc1101.jpg 650w,\n/static/fb178f94d97f1eb7776946878a9d8e61/ce471/cc1101.jpg 975w,\n/static/fb178f94d97f1eb7776946878a9d8e61/bee4e/cc1101.jpg 1300w,\n/static/fb178f94d97f1eb7776946878a9d8e61/8de17/cc1101.jpg 1564w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n      />\n  </span>\n  </a></p>\n<p>With basic functionality going, I started reading a lot of Rust embedded projects that did various things with SPI to see how they dealt with register interaction. The <a href=\"https://github.com/lolzballs/rfm69\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">rfm69</a> crate (SPI for some other radio chip) had a couple of nice ideas on express values that would be written to multiple registers:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\">rfm69<span class=\"token punctuation\">.</span><span class=\"token function\">packet_length</span><span class=\"token punctuation\">(</span>PacketLength<span class=\"token punctuation\">::</span><span class=\"token function\">Fixed</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Here one register would be configured to fixed mode, and another would get the length. In cases where some mode had constraints on the length in one way or another, that could be described in a deterministic fashion.</p>\n<p>The other crate was <a href=\"https://github.com/japaric/enc28j60\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">enc28j60</a>, which contained a good macro to describe registers including sub-fields:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token function\">register!</span><span class=\"token punctuation\">(</span>PHCON2<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> u16<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token attribute attr-name\">#[doc = \"PHY Half-Duplex Loopback Disable bit\"]</span>\n    hdldis <span class=\"token operator\">@</span> <span class=\"token number\">8</span><span class=\"token punctuation\">,</span>\n    <span class=\"token attribute attr-name\">#[doc = \"Jabber Correction Disable bit\"]</span>\n    jabber <span class=\"token operator\">@</span> <span class=\"token number\">10</span><span class=\"token punctuation\">,</span>\n    <span class=\"token attribute attr-name\">#[doc = \"Twisted-Pair Transmitter Disable bit\"]</span>\n    txdis <span class=\"token operator\">@</span> <span class=\"token number\">13</span><span class=\"token punctuation\">,</span>\n    <span class=\"token attribute attr-name\">#[doc = \"PHY Force Linkup bit\"]</span>\n    frclnk <span class=\"token operator\">@</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>I had already something similar in my project, but decided that this was a better representation. </p>\n<p>With this in place I started to carve out some kind of API, with many of the functions using enum-based arguments for readability. Internally I encoded the <a href=\"http://www.ti.com/lit/ds/symlink/cc1101.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">CC1101 register documentation</a> into macro definitions, and started to tear down the huge obfuscated block of hard-coded register values to their named versions. This turned out to be quite a huge cleanup. Most of the hard-coded register values the other projects used were actually the reset values of the registers, so they could be removed, and others were values I started to have APIs for, and others could be removed without affecting the reception. Today I still have a dirty <code class=\"language-text\">set_defaults()</code> function that sets a number of registers that I still haven’t made APIs for, but it’s a lot smaller, and it will be removed in the future.</p>\n<p>The final hurdle was how to design the <code class=\"language-text\">receive()</code> function. The SPI interaction works by transferring a buffer with an address in the first position, and the rest of the buffer will be filled with data once it gets back. This is gated by something called <em>chip-select</em>, that is set to low before transfer, and then high afterwards. In-between that low/high gating, you’re supposed to be able to be able to do multiple transfers. The need for this arises because I envisioned an API like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">receive(&amp;address, &amp;buffer) -&gt; result&lt;length,error&gt;</code></pre></div>\n<p>However, the layout of the buffer after a single <code class=\"language-text\">RXFIFO</code> transfer:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[register-address, packet-length, destination-address, payload...]</code></pre></div>\n<p>To have the payload, and nothing else, written to a statically allocated buffer, you would have to first transfer a buffer with the register address, with room enough to read out length and destination address, and then a second transfer to read out the payload. This turned out to be somewhat broken on Raspberry Pi resulting in the second transfer being filled with garbage. When setting up SPI on Linux using <code class=\"language-text\">spidev</code> crate, it’s possible to configure it with <code class=\"language-text\">SPI_NO_CS</code> to signal that you will be doing the <em>chip-select</em> manually in the application. I want to do this as this is something the driver needs to do if used in an embedded environment, but it simply didn’t work. So it seemed like the only way to have an API like that, for use on Linux, would be to do the transfer with a big enough buffer, and then copy the payload to the API supplied buffer. Obviously a suboptimal solution. After a long clueless (on my behalf) discussion with a very patient Raspberry Pi kernel developer it turned out that there was a workaround by applying the <code class=\"language-text\">spi0-hw-cs</code> device tree overlay at boot-time, and once done, multiple transfers within a <em>chip-select</em> worked. This was considered a flaw, and has now been <a href=\"https://github.com/raspberrypi/linux/commit/94996038c16b3f75cde4f82de39486b024925e48\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">fixed</a> in the kernel. To get the working kernel, run <code class=\"language-text\">sudo rpi-update</code>.</p>\n<p>So this is where I am now, the <code class=\"language-text\">init</code> function in the RfCat example above translates to the following Rust code:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> cc1101 <span class=\"token operator\">=</span> Cc1101<span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>spi<span class=\"token punctuation\">,</span> cs<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\ncc1101<span class=\"token punctuation\">.</span><span class=\"token function\">set_defaults</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\ncc1101<span class=\"token punctuation\">.</span><span class=\"token function\">set_frequency</span><span class=\"token punctuation\">(</span><span class=\"token number\">868_000_000u64</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\ncc1101<span class=\"token punctuation\">.</span><span class=\"token function\">set_modulation</span><span class=\"token punctuation\">(</span>Modulation<span class=\"token punctuation\">::</span>BinaryFrequencyShiftKeying<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\ncc1101<span class=\"token punctuation\">.</span><span class=\"token function\">set_sync_mode</span><span class=\"token punctuation\">(</span>SyncMode<span class=\"token punctuation\">::</span><span class=\"token function\">MatchFull</span><span class=\"token punctuation\">(</span><span class=\"token number\">0xD201</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\ncc1101<span class=\"token punctuation\">.</span><span class=\"token function\">set_packet_length</span><span class=\"token punctuation\">(</span>PacketLength<span class=\"token punctuation\">::</span><span class=\"token function\">Variable</span><span class=\"token punctuation\">(</span><span class=\"token number\">17</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span>\ncc1101<span class=\"token punctuation\">.</span><span class=\"token function\">set_address_filter</span><span class=\"token punctuation\">(</span>AddressFilter<span class=\"token punctuation\">::</span><span class=\"token function\">Device</span><span class=\"token punctuation\">(</span><span class=\"token number\">0x3e</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>And an optimized build translates that code to constant values passed to SPI transfers.</p>\n<p>The reception of packets is done by:</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> dst <span class=\"token operator\">=</span> <span class=\"token number\">0u8</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> payload <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0u8</span><span class=\"token punctuation\">;</span> <span class=\"token number\">17</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> length <span class=\"token operator\">=</span> cc1101<span class=\"token punctuation\">.</span><span class=\"token function\">receive</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> dst<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> payload<span class=\"token punctuation\">)</span><span class=\"token operator\">?</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Where possible errors are device specific IO-errors, overflows, and crc errors. If no errors occurred, the API user will have a length, destination address and a payload, where the destination address might be either the device address, or one of the broadcast addresses depending on configuration.</p>\n<p>While on this journey it became apparent that the original author of the CC1101 crate did not have enough time to help out, and I was entrusted with taking over the authorship of crate. This change has been finalized and I’ve now <a href=\"https://crates.io/crates/cc1101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">published a version</a> that can receive my <a href=\"https://github.com/dsvensson/sparsnas-rs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Sparsnäs packets</a>.</p>\n<p>There is no transmission available as I only have one radio module, but I’ve ordered some extra ones in hope of getting time to add that as well. I don’t have any immediate need to send data, so it depends on how much spare time I have for this. I hope that this crate is useful for others, and I get some help in improving the structure of the code, and of course help with adding the missing features. I’ve dumped many of my ideas forward as issues in the <a href=\"https://github.com/dsvensson/cc1101\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub repository</a>.</p>","fields":{"slug":"posts/2018-07-13-cc1101","readingTime":{"text":"9 min read"}},"frontmatter":{"title":"Electrosmog trapping with CC1101","date":"13 Jul '18"}},"headerImage":{"childImageSharp":{"fluid":{"tracedSVG":"data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='400' height='27'%3e%3cpath d='M2 1L1 13l-1 6c0 4 0 4 3 4 2 0 2 0 1 1H1l-1 1c0 2 3 2 15 2h14v-5c0-5-1-6-3-4v3c0 1-2 2-5 2l-4 1-2 1-2-1c0-2 6-4 9-4 3 1 3-1-1-2-3 0-1-2 4-2 3 0 4-1 4-3l-1-3H16C5 10 5 10 5 3c0-3-2-4-3-2m32 13v13h9c7 0 9 0 9-2 0 0-1-2-3-2-3-1-3-1-2-8V9h-3l-4 1V5c0-5 0-5-3-5h-2l-1 14m20-2v11h4c3 0 4 0 5 2 0 2 1 2 14 2 16 0 15 1 15-11 0-8 1-12 3-12l1 10c0 6 0 9 1 8 1-2 1-2 1 0 1 1 1 2 2 1l2 1 1 2V4c0-3-1-4-6-4-6 0-6 0-5 2 0 4-8 7-20 7h-9V0h-9v12m57-5c-1 8 0 14 4 17v1l-2 1 14 1 14-1h2l10 1c11 0 11 1 11-22V0l-2 3-2 4c1 1 0 1-3 1l-7 1-5-1c-3-3-2-5 1-5l3-1h-3l-3-1-2-1-1 1c1 0-1 3-3 3l-3-2c-3-2-4-2-9-2h-11c-3 0-3 0-3 7m68-4c0 3 0 3 2 1 0-1 2-2 3-1 1 0 1 1-1 3-2 1-2 2-1 2v1l-1 3c0 1-1 2-2 1v6c0 1 1 2 5 2 7 2 8 2 2 2l-6 1h2l3 1c0 1 2 2 10 2 9 0 10 0 10-2 0-1 1-2 3-2h3V0h-33l1 3m36-2c-2 2 0 26 1 26v-1c0-2 1-2 3 0l9 1h8l-2-3-1-2c1-1-6-14-7-13-2 1-5-1-5-5-1-3-1-3-2-1l-1 3V3c0-2-2-4-3-2m99 0c-1 2 3 8 5 9v3l-1-1-2-1 1 2v2c-2 1-2 1-2-1s0-2-1-1h-2l-1 2 1 2 1-1h1l-1 2-1 3-2-3c-2-2-7-2-5 0h2l1 1-3 1c-2 0-2 0-2 2l1 3c0 2 1 2 48 2h48V15c0-10 0-11-2-11-1 0-2 0-2-2 0-3-9-3-11 0v2h-1l-1 1c-1 1-1 0-1-2 1-4-1-4-2 0 0 2-1 2-1 1V2c0-2 0-2-1-1l-2 1c1 4-1 6-4 5-4 0-6-2-3-2 2 0 2 0 1-1-2 0-2-1-1-2l2 1c0 2 1 1 3-1 1-2 0-2-3-2l-7 2c-2 1-2 2-1 2h2l-2 1-2 2 2 1c2-1 4 0 4 2l-5 1-6 1h-1l2-2 1-2-2-4V0h-9c-9 0-10 0-10 2l-1 3V2c0-2-1-2-3-2l-3 1h-2c-2-1-7-1-7 1l1 1v1c0 2-2 0-2-2s-5-3-6-1m-44 7l-1 1c-1-1-1 1-1 3 0 4 0 4-1 1 0-3-1-3-5-4l-6-1c-1 0-1 4 1 10l2 6c1 3 1 3 11 3 7 0 9 0 9-2v-3l-2-2-2-5-3-5c-1-4-2-5-2-2' fill='%23d3d3d3' fill-rule='evenodd'/%3e%3c/svg%3e","aspectRatio":14.867924528301886,"src":"/static/843c5f7defd25c41f8cae57182fd6f1f/1bdc6/wastelands-header.jpg","srcSet":"/static/843c5f7defd25c41f8cae57182fd6f1f/accda/wastelands-header.jpg 200w,\n/static/843c5f7defd25c41f8cae57182fd6f1f/fc61b/wastelands-header.jpg 400w,\n/static/843c5f7defd25c41f8cae57182fd6f1f/1bdc6/wastelands-header.jpg 800w,\n/static/843c5f7defd25c41f8cae57182fd6f1f/34bdc/wastelands-header.jpg 1200w,\n/static/843c5f7defd25c41f8cae57182fd6f1f/bdccb/wastelands-header.jpg 1600w,\n/static/843c5f7defd25c41f8cae57182fd6f1f/0ffcb/wastelands-header.jpg 3940w","sizes":"(max-width: 800px) 100vw, 800px"}}},"indexImage":null},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"posts/2018-07-13-cc1101","previous":{"fields":{"slug":"posts/2013-01-13-spotify"},"frontmatter":{"title":"Spotify wishes for 2013"}},"next":{"fields":{"slug":"posts/2019-06-27-restclient"},"frontmatter":{"title":"restclient.el"}}}}}